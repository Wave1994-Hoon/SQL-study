# 1. DBMS 아키텍처

## 1.1 DBMS 아키텍처 개요

#### Data Flow

---
<img width="600" src="https://user-images.githubusercontent.com/60383031/124362438-c33d7f00-dc6f-11eb-95b3-dd99c8866b54.jpeg">

<br>

#### 쿼리 평가 엔진

---
- 사용자로부터 입력받은 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지를 결정
    - 계획을 세우고 실행하는 DBMS의 핵심 기능을 담당하는 모듈
    

- 실행 계획: 쿼리 평가 엔진에서 결정되는 계획
  

- 접근 메서드: 실행 계획에 기반을 둬서 데이터에 접근하는 방법

<br>

#### 버퍼 매니저

---
- 역할
    - DBMS는 버퍼라는 메모리 영역을 확보한다. 이 영역을 관리해주는 매니저
    - 디스크 용량 매나저와 함께 연동되어 작동한다.

<br>

#### 디스크 용량

---
- 역핳: 어디에 어떻개 데이터를 저장할지를 관리하며, 데이터의 읽고 쓰기를 제어

<br>

#### 트랜잭션 매니저와 락 매니저

---
- 여러 사람이 동시에 데이터배이스에 접근한다면 ?
    - 각각의 처리를 DBMS 내부에서 트랜잭션 단위로 관리 해줘야함 
    

- 역할
    - 트랜잭션의 정헙성을 유지하면서 실행   
    - 필요한 경우 데이터에 락을 걸어서 다른 사람의 요청을 대기시키는 역할 수행


<br>

#### 리커버리 매니저 

---
- 역할: 데이터를 정기적으로 백업하고, 문재가 일어났을 때 복구 수행 

<br>


## 1.2 DBMS 버퍼
#### DBMS와 기억장치의 관계

---
- 하드디스크(HDD)
    - 대부분 DBMS가 데이터를 저장하는 매체
    - 2차 기억장치이기 때문에 장단점이 딱히 없음


- 메모리
    - HDD에 비하여 비용이 크기 때문에 하드웨어 1대에 탑재할 수 있는 양은 크지 않다.  


- 버퍼를 활용한 속도 향상
    
    <br>
    <img width="600" src="https://user-images.githubusercontent.com/60383031/124362471-026bd000-dc70-11eb-95a9-2d7e257f668f.jpeg">
    
    - 장점
        - 자주 접근하는 데이터를 메모리 위에 올림 ----> 메모리에서 빠르게 검색 가능
        - 이러한 성능 향상을 목적으로 데이터를 저장하는 메모리를 `버퍼 또는 캐시`라고 한다.
        - 버퍼 매니저: 고속 접근이 가능한 버퍼에 데이터를 어떻게 어느 정도의 기간 동안 올릴지를 관리

<br>

#### 메모리 위에 있는 두개의 버퍼

---
- 데이터 캐시
    - MySQL 초기 값: 125MB (5.7 version InnoDB 기준)
    - 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역
    - SELECT 구문을 실행할 때 조회하려는 데이터가 데이터 캐시에 있다면 빠르게 응답 가능 (디스크 접근 x)
    - 반대로 조회 하고자 하는 데이터가 데이터 캐시에 없다면 응답 속도는 느려진다.
  
  
- 로그 버퍼 
    - MySQL 초기 값: 8MB (5.7 version InnoDB 기준)
    - 갱신 처리 (INSERT, UPDATE, DELETE, MERGE)와 관련된 버퍼  
    - DBMS는 갱신과 관련된 SQL 구문을 사용자로부터 받으면, 곧바로 저장소에 있는 데이터를 변경하지 않는다.
    - 일단 로그 버퍼 위에 변경 정보를 보내고 이후에 디스크에 변경을 수행 (갱신 처리는 비동기로 수행)
    
    <br>  
    <img width="600" src="https://user-images.githubusercontent.com/60383031/124362563-a6557b80-dc70-11eb-8bfb-f25e2bea72f4.jpeg">


<br>

#### 메모리의 성질이 초래하는 트레이프오프

---
- 휘발성의 문제점 
    - 휘발성의 가장 큰 문제점은 장애가 났을 때, 메모리에 있던 데이턱 모두 사라진다는 것이다.
    - 그로 인하여 데이터 부정합이 발생한다.
  

- 데이터 캐시
    - 원본 데이터는 디스크에 있기 대문에 장애로부터 문제없음

  
- 로그 버퍼
    - 복구가 불가능 하다.
    - 은행 입출금 또는 카드 인출이 데이터베이스에 반영되지 않을 수 도 있다.
    

- 커밋
    - 커밋이란 갱신 처리를 확정하는 것
    - DBMS는 커밋된 데이터를 영속화한다.

<br>

#### 시스템 특성에 따른 트레이드오프

---
- 데이터 캐시와 로그 버퍼 크기
  - 기본적으로 데이터 버퍼 > 로그 버퍼
  - 이는 데이터베이스가 기본적으로 검색을 메인으로 처리한다고 가정
  

- 정리
    - 데이터 버퍼가 크게 잡혀있으면 검색 처리와 관련된 처리가 중심
    - 반면에 로그 버퍼가 크게 잡혀있으면 갱신 처리와 관련해 큰 부하가 걸릴 것을 감안한 설계 


<br>

#### 추가적인 메모리 영역 '워킹 메모리'

---
- DBMS는 `워킹 메모리`라는 메모리 영역을 하나 더 가지고 있다.
  

- 역할
    - 정렬 또는 해시 관련 처리에 사용되는 작업 영역
    - 정렬: ORDER BY, 집합 연산 등
    - 해시: 주로 테이블 등의 결합 

  
- MySQL 5.7 version
    - 명칭: 정렬 버퍼
    - 기본 값: 256KB


  
- 해당 영역은 정렬 또는 해시가 필요할 때만 사용되고, 종료되면 해제되는 임시 영역
  

- 만약 해당 영역의 크기가 다루는 데이터 량 보다 작다면 ??
    - 디스크를 사용하여 SWAP 발생
      <br>  
      <img width="600" src="https://user-images.githubusercontent.com/60383031/124362622-f9c7c980-dc70-11eb-8f42-b0f75f773318.jpeg">


<br>

## 1.3 DBMS 실행 계획
#### 데이터에 접근하는 방법은 어떻게 결정할까?

---
- Flow
  <br>  
  <img width="600" src="https://user-images.githubusercontent.com/60383031/124362955-54fabb80-dc73-11eb-9109-3a4f39d86e8b.jpeg"> 


- 파서
    - 역할: SQL 분석 및 변환
        - 사용자로부터 입력 받은 SQL 구문이 항상 올바르다라는 보증이 없기 때문에
        - SQL 구문을 정형적인 형식으로 변환해줍니다.
        - 이렇게 해야 DBMS 내부에서 일어나는 후속 처리가 효율화 


- 옵티마이저 (최적화)
    - 역할: 실행 계획(데이터 접근법)을 최적화
        - 인덱스 유무, 데이터 분산 또는 편향 정도, DBMS 내부 매개변수 등의 조건을 고려해서, 선택한 많은 실행 계획 작성
        - 작성된 실행 계획들의 비용 게산
        - 가장 낮은 비용을 가진 실행 계획 선택

    
- 카탈로그 매니저 (통계 정보)
    - 역할: 실행 계획을 세울 때 중요한 정보를 제공 (To. 옵티마이저)
        - DBMS의 내부 정보를 모여놓은 테이블들로, 테이블 또는 인덱스의 통계 정보 저장
         

- 플랜 평가
    - 역할: 실행 계획을 전달 받아 최적의 실행 결과를 선택 (From. 옵티마이저)
        - 하나의 실행 계획을 선택하면, 이후에 DBMS는 실행 계획을 절차적인 코드로 변환하고 데이터 접근 수행
            - 인간의 언어 to DBMS가 실행할 수 있는 형태


<br>

#### 옵티마이저 통계 정보

---
- 이슈: 옵티마이저가 명령하는 대로 다 잘 처리해주는 만능은 아니다.
    - 카탈로그 매니저가 관리하는 통계 정보에 대해서는 데이터베이스 엔지니어가 항상 신경 써줘야 한다.
    - 플랜 선택 옵티마이저에게 맡김 --> 최적의 플랜이 선택되지 않은 경우가 발생 가능
  

- 원인: 통계 정보 부족 
    - 카탈로그 정보가 생신되지 않는 다면, 옵티마이저는 과거 데이터를 기준으로 실행 계획을 세운다.
    - 예시 
        - (1) 초기 테이블 레코드 개수 0
        - (2) 1억 건 데이터 올림
        - (3) 카탈로그 정보 갱신 하지 않음
        - (4) 옵티마이저는 데이터 0개를 기준을 플랜 생성


- 카탈로그에 존재하는 통계 정보
    - (1) 각 테이블 레코드 수
    - (2) 각 테이블의 필드 수와 필드 크기
    - (3) 필드의 카디널리티(값의 개수)
    - (4) 필드 값의 히스토그램 (어떤 값이 얼마나 분포되어 있는가)
    - (5) 필드 내부에 있는 NULL 수
    - (6) 인덱스 정보 


<br>

#### 최적의 실행 계획이 작성되게 하려면

---
- 테이블 데이터가 많이 바뀌면 카탈로그의 통계 정보도 함께 갱신해야 한다.
- MySQL 명령어
    ```
    ANALYZE TABLE [스키마 이름].[테이블 이름]
    ```

- 궁금한 점 
    - JPA 혹은 MyBatis 로 개발할 때, INSERT, UPDATE 쿼리는 날림 
    - 하지만 카탈로그 통계 정보를 갱신하는 명령어는 날리지 않음
    - 이 부분은 JPA 혹은 MyBatis 에서 해주는 것인가 ??

<br>

## 1.4 실행 계획이 SQL 구문의 성능 결정 (RealMySQL 참고)
#### 서론

---
- 반응 지연이 방생하는 경우
    - (1) 통계 정보 부족
    - (2) 최적의 경로를 선택하였지만 느린 경우
    - (3) 통계 정보는 최신이지만, SQL 구문이 너무 복잡하여 옵티마이저가 최적의 접근 경로 선택 못함


<br>
    
#### 실행 계획 확인 방법

---
- MySQL: 실행 계획 확인 방법 
    - 기본
        ```
        EXPLAIN [SQL 구문]
        ```
      
    - 심화
        - (1) EXTENDED
        ```
        EXPLAIN EXTENDED [SQL 구문]
        ```    
    
        <br>  
        <img width="600" src="https://user-images.githubusercontent.com/60383031/124374119-91f69a80-dcd3-11eb-8e7a-fcbe6cea7ab5.png">

        - (2) PARTITIONS
        ```
        EXPLAIN PARTITIONS [SQL 구문]
        ```    
        <br>  
        <img width="600" src="https://user-images.githubusercontent.com/60383031/124374149-c8341a00-dcd3-11eb-9871-67f6c4fc0bbc.png">


- 단점 
    - UPDATE나 INSERT, DELETE 문장에 대해서는 실행 계획을 확인 할 방법이 없다.


- 참고
    - https://zorba91.tistory.com/292

<br>


#### 테이블 풀 스캔 실행 계획

---
<br>  
<img width="600" src="https://user-images.githubusercontent.com/60383031/124374293-0978f980-dcd5-11eb-850e-44727e246436.png">


<br>

#### 인데스 스캔의 실행 계획

---
<br>  
<img width="600" src="https://user-images.githubusercontent.com/60383031/124374373-bf444800-dcd5-11eb-8663-0335cf33e71e.png">


